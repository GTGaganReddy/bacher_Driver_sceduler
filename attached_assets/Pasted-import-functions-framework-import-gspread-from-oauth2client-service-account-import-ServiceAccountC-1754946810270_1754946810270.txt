import functions_framework
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from flask import json, jsonify, request
from datetime import datetime
from google.cloud import secretmanager
import time
from typing import List, Dict, Any

def get_secret():
    client = secretmanager.SecretManagerServiceClient()
    name = "projects/driver-schedule-updater/secrets/gspread-service-account/versions/latest"
    response = client.access_secret_version(request={"name": name})
    secret_string = response.payload.data.decode("UTF-8")
    return json.loads(secret_string)

class BatchSheetUpdater:
    """Handles batch updates to minimize API calls"""
    
    def __init__(self, sheet):
        self.sheet = sheet
        self.updates = []  # Store all updates for batch processing
        self.max_retries = 3
        self.base_delay = 1  # seconds
    
    def add_update(self, row: int, col: int, value: str):
        """Add an update to the batch queue"""
        self.updates.append({
            'range': f'{self.col_to_letter(col)}{row}',
            'value': value
        })
    
    def add_delete(self, row: int, col: int):
        """Add a delete operation to the batch queue (sets cell to empty)"""
        self.updates.append({
            'range': f'{self.col_to_letter(col)}{row}',
            'value': ''  # Empty string effectively deletes content
        })
    
    def add_range_delete(self, start_row: int, end_row: int, start_col: int, end_col: int):
        """Delete a range of cells"""
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                self.add_delete(row, col)
    
    def clear_driver_day(self, driver_row: int, date_block_start: int):
        """Clear all cells for a driver's specific day (4-column block)"""
        for col_offset in range(4):  # dienst, vad, diäten, km columns
            self.add_delete(driver_row, date_block_start + col_offset)
    
    def col_to_letter(self, col_num: int) -> str:
        """Convert column number to letter (1=A, 2=B, etc.)"""
        result = ""
        while col_num > 0:
            col_num -= 1
            result = chr(col_num % 26 + ord('A')) + result
            col_num //= 26
        return result
    
    def execute_batch_update(self) -> Dict[str, Any]:
        """Execute all queued updates in a single batch operation"""
        if not self.updates:
            return {"success": True, "updates_count": 0}
        
        try:
            # Group updates by range for batch_update
            batch_data = []
            for update in self.updates:
                batch_data.append({
                    'range': update['range'],
                    'values': [[update['value']]]
                })
            
            # Use batch_update instead of individual update_cell calls
            success = self.retry_api_call(
                lambda: self.sheet.batch_update(batch_data)
            )
            
            if success:
                update_count = len(self.updates)
                self.updates.clear()  # Clear the queue after successful update
                return {
                    "success": True, 
                    "updates_count": update_count,
                    "message": f"Successfully updated {update_count} cells in batch"
                }
            else:
                return {
                    "success": False,
                    "error": "Batch update failed after retries"
                }
                
        except Exception as e:
            print(f"Batch update error: {str(e)}")
            return {
                "success": False,
                "error": f"Batch update failed: {str(e)}"
            }
    
    def retry_api_call(self, api_function, max_retries: int = None):
        """Execute API call with exponential backoff retry logic"""
        if max_retries is None:
            max_retries = self.max_retries
            
        for attempt in range(max_retries):
            try:
                result = api_function()
                return result
            except Exception as e:
                error_str = str(e).lower()
                
                # Check if it's a rate limit error
                if 'rate limit' in error_str or '429' in error_str or 'quota' in error_str:
                    if attempt < max_retries - 1:  # Don't sleep on last attempt
                        delay = self.base_delay * (2 ** attempt)  # Exponential backoff
                        print(f"Rate limit hit, waiting {delay} seconds (attempt {attempt + 1}/{max_retries})")
                        time.sleep(delay)
                        continue
                    else:
                        print(f"Rate limit exceeded after {max_retries} attempts")
                        raise e
                else:
                    # Non-rate limit error, don't retry
                    raise e
        
        return None

def process_drivers_batch(sheet, drivers_data: List[Dict]) -> Dict[str, Any]:
    """Process multiple drivers using batch updates to minimize API calls"""
    
    # Initialize batch updater
    batch_updater = BatchSheetUpdater(sheet)
    results = []
    
    # Get sheet data once at the beginning
    try:
        # Get driver names (column A) and dates (row 5) in single calls
        driver_col = batch_updater.retry_api_call(lambda: sheet.col_values(1))
        date_row = batch_updater.retry_api_call(lambda: sheet.row_values(5))
        
        if not driver_col or not date_row:
            return {
                "success": False,
                "error": "Failed to fetch sheet data",
                "results": []
            }
            
    except Exception as e:
        print(f"Error fetching sheet data: {str(e)}")
        return {
            "success": False,
            "error": f"Failed to fetch sheet data: {str(e)}",
            "results": []
        }
    
    # Process each driver and queue updates
    for driver_data in drivers_data:
        result = process_single_driver_batch(
            driver_data, driver_col, date_row, batch_updater
        )
        results.append(result)
    
    # Execute all updates in a single batch
    batch_result = batch_updater.execute_batch_update()
    
    # Count successes and failures
    success_count = sum(1 for r in results if r["success"])
    error_count = len(results) - success_count
    
    return {
        "success": batch_result["success"] and error_count == 0,
        "total_processed": len(drivers_data),
        "successful_updates": success_count,
        "failed_updates": error_count,
        "batch_update_result": batch_result,
        "results": results
    }

def process_single_driver_batch(driver_data: Dict, driver_col: List, date_row: List, batch_updater: BatchSheetUpdater) -> Dict[str, Any]:
    """Process a single driver and add updates to batch queue"""
    
    try:
        driver = driver_data.get("driver")
        route = driver_data.get("route")
        hour = driver_data.get("hour")
        remaining_hour = driver_data.get("remaining_hour")
        date = driver_data.get("date")
        status = driver_data.get("status", "")
        action = driver_data.get("action", "update")  # New field for delete operations

        # Validate required fields
        if not driver or not date:
            return {
                "success": False,
                "driver": driver,
                "error": "Driver and date are required"
            }

        # Find driver row
        driver_row = None
        for i, cell_value in enumerate(driver_col):
            if cell_value and str(cell_value).strip().lower() == str(driver).strip().lower():
                driver_row = i + 1
                break
        
        if not driver_row:
            return {
                "success": False,
                "driver": driver,
                "error": f"Driver {driver} not found"
            }

        # Find date column
        date_str = datetime.strptime(date, "%Y-%m-%d").strftime("%d-%m-%Y")
        date_block_start = None
        
        print(f"Looking for date: '{date_str}' for driver: {driver}")
        
        # Search for date in row 5
        for i, val in enumerate(date_row):
            if val and str(val).strip() == date_str:
                date_block_start = i + 1  # Convert to 1-based indexing
                print(f"Found date '{date_str}' starting at column {date_block_start}")
                break
        
        # Try alternative date formats if not found
        if not date_block_start:
            alt_formats = ["%d/%m/%Y", "%m-%d-%Y", "%Y-%m-%d", "%d.%m.%Y", "%d-%m-%y", "%d-%m-%Y"]
            for fmt in alt_formats:
                try:
                    alt_date_str = datetime.strptime(date, "%Y-%m-%d").strftime(fmt)
                    print(f"Trying alternative format: '{alt_date_str}'")
                    for i, val in enumerate(date_row):
                        if val and str(val).strip() == alt_date_str:
                            date_block_start = i + 1
                            print(f"Found date '{alt_date_str}' starting at column {date_block_start}")
                            break
                    if date_block_start:
                        break
                except:
                    continue
        
        if not date_block_start:
            return {
                "success": False,
                "driver": driver,
                "error": f"Date {date_str} not found in row 5",
                "available_dates": [str(val).strip() for val in date_row if val]
            }

        # Handle delete actions
        if action == "delete":
            batch_updater.clear_driver_day(driver_row, date_block_start)
            print(f"Queued delete for driver {driver} at row {driver_row}, date block starting at column {date_block_start}")
            return {
                "success": True,
                "driver": driver,
                "action": "deleted",
                "cleared_row": driver_row,
                "cleared_columns": list(range(date_block_start, date_block_start + 4))
            }

        # Handle remaining hour deletion if explicitly requested
        if action == "delete_remaining_hour":
            batch_updater.add_delete(driver_row, 4)  # Column D
            print(f"Queued remaining hour deletion for driver {driver} at row {driver_row}")
            return {
                "success": True,
                "driver": driver,
                "action": "deleted_remaining_hour",
                "cleared_cell": f"D{driver_row}"
            }

        # Calculate column positions for updates
        dienst_col = date_block_start      # First column of the block
        vad_col = date_block_start + 1     # Second column
        diäten_col = date_block_start + 2  # Third column  
        km_col = date_block_start + 3      # Fourth column
        
        print(f"Queuing updates for driver {driver} at row {driver_row}, columns: dienst={dienst_col}, vad={vad_col}, diäten={diäten_col}, km={km_col}")

        # Queue updates instead of immediate execution
        if status in ["F", "U"]:
            # Simple value updates for F/U status
            batch_updater.add_update(driver_row, dienst_col, status)
            batch_updater.add_update(driver_row, vad_col, "0:00")
            batch_updater.add_update(driver_row, diäten_col, "0")
            batch_updater.add_update(driver_row, km_col, "")
            print(f"Queued {status} status updates for driver {driver} at row {driver_row}")
                
        else:
            # Calculate rounded hours for Diäten column
            diaten_value = 0  # Change to number instead of string
            if hour:
                try:
                    if ":" in hour:
                        time_parts = hour.split(":")
                        if len(time_parts) == 2:
                            hours = int(time_parts[0])
                            minutes = int(time_parts[1])
                            diaten_value = hours + 1 if minutes > 30 else hours  # Number instead of string
                        else:
                            print(f"Warning: Invalid hour format '{hour}', using 0 for Diäten")
                            diaten_value = 0  # Number
                    else:
                        hours = int(hour)
                        diaten_value = hours  # Number
                
                except (ValueError, IndexError) as e:
                    print(f"Warning: Could not parse hour '{hour}': {e}, using 0 for Diäten")
                    diaten_value = 0  # Number

            print(f"Hour: {hour} -> Diäten: {diaten_value}")

            # Queue updates for regular status
            batch_updater.add_update(driver_row, dienst_col, route or "")
            batch_updater.add_update(driver_row, vad_col, hour or "")
            batch_updater.add_update(driver_row, diäten_col, diaten_value)  # Now passing a number
            batch_updater.add_update(driver_row, km_col, "")
            print(f"Queued normal work day updates for driver {driver} at row {driver_row}")

        # Queue remaining hour update (column D = 4)
        if remaining_hour is not None:
            batch_updater.add_update(driver_row, 4, str(remaining_hour))

        return {
            "success": True,
            "driver": driver,
            "updated_row": driver_row,
            "updated_columns": {
                "dienst": dienst_col,
                "vad": vad_col,
                "diäten": diäten_col,
                "km": km_col
            }
        }

    except Exception as e:
        print(f"Error processing driver {driver_data.get('driver', 'Unknown')}: {str(e)}")
        return {
            "success": False,
            "driver": driver_data.get("driver", "Unknown"),
            "error": f"Failed to process: {str(e)}"
        }

# Legacy function for backward compatibility
def process_single_driver(sheet, driver_data):
    """Legacy function - now uses batch processing internally"""
    batch_updater = BatchSheetUpdater(sheet)
    
    try:
        driver_col = sheet.col_values(1)
        date_row = sheet.row_values(5)
    except Exception as e:
        return {
            "success": False,
            "driver": driver_data.get("driver", "Unknown"),
            "error": f"Failed to fetch sheet data: {str(e)}"
        }
    
    result = process_single_driver_batch(driver_data, driver_col, date_row, batch_updater)
    
    if result["success"]:
        batch_result = batch_updater.execute_batch_update()
        if not batch_result["success"]:
            result["success"] = False
            result["error"] = batch_result.get("error", "Batch update failed")
    
    return result

@functions_framework.http
def update_sheet(request):
    """Main function with improved batch processing and delete functionality"""
    
    try:
        print(f"Request method: {request.method}")
        print(f"Request content type: {request.content_type}")
        
        req = request.get_json()
        print(f"Request body: {req}")
        
        if not req:
            return jsonify({"error": "No JSON body provided or invalid JSON"}), 400
            
    except Exception as e:
        print(f"Error parsing request: {str(e)}")
        return jsonify({"error": f"Invalid request format: {str(e)}"}), 400

    # Parse drivers data
    if "drivers" in req:
        drivers_data = req["drivers"]
        if not isinstance(drivers_data, list):
            return jsonify({"error": "drivers must be an array"}), 400
        if len(drivers_data) == 0:
            return jsonify({"error": "drivers array cannot be empty"}), 400
    elif isinstance(req, list):
        drivers_data = req
    else:
        drivers_data = [req]

    print(f"Processing {len(drivers_data)} drivers")

    # Authentication
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds_dict = get_secret()
        creds = ServiceAccountCredentials.from_json_keyfile_dict(creds_dict, scope)
        client = gspread.authorize(creds)
        sheet = client.open("Driver-Schedule").sheet1
        print("Successfully authenticated and opened sheet")
    except Exception as e:
        print(f"Authentication/sheet error: {str(e)}")
        return jsonify({"error": f"Failed to authenticate or open sheet: {str(e)}"}), 500

    # Process drivers
    if len(drivers_data) > 1:
        # Use batch processing for multiple drivers
        result = process_drivers_batch(sheet, drivers_data)
        return jsonify(result)
    else:
        # Single driver - maintain backward compatibility
        result = process_single_driver(sheet, drivers_data[0])
        if result["success"]:
            if result.get("action") in ["deleted", "deleted_remaining_hour"]:
                # Return delete-specific response
                return jsonify({
                    "success": True,
                    "action": result["action"],
                    "driver": result["driver"],
                    **{k: v for k, v in result.items() if k not in ["success", "action", "driver"]}
                })
            else:
                # Return update response
                return jsonify({
                    "success": True,
                    "updated_row": result["updated_row"],
                    "updated_columns": result["updated_columns"]
                })
        else:
            status_code = 404 if "not found" in result["error"].lower() else 500
            return jsonify({"error": result["error"]}), status_code